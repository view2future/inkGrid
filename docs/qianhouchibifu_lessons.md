# 前后赤壁赋（kai_021）数据修复经验总结（可复用）

这份文档总结了修复 `kai_021`（前后赤壁赋 · 文徵明小楷）一字多形数据的经验教训，目标是让“以后切其他碑帖”时：
- 初版就尽量对
- 出错时能快速定位、快速迭代
- 尽可能把人工反馈转化为“可执行的修复动作”

## 一、常见根因（踩坑清单）

### 1）文件名 / 标签 / 图片内容不一致
前端一字多形是按 `index.json -> files[].char` 来分组的。
只要“图片内容”和 `char` 不一致，就会出现“点之出现如/而/万…”这种随机混字。
结论：**不能只修 label，必须确保 PNG 内容本身对应正确字符。**

### 2）题跋/题识混入正文序列
很多作品的“正文”和“题跋/年款/题签”共存。
如果把题跋字符切进正文 901 字的序列里，哪怕你强行对齐 gold_text，也一定会产生大规模错位。
结论：**必须先明确“目标范围”是正文-only 还是全卷。**

### 3）缺字位（missing slots）用“随便填坑”会毁全局
一旦有缺字位，如果用尾部或其他位置的 glyph 去补，就会造成连锁错位。
结论：**缺字位必须“回原图重裁”，不能靠复制别的 glyph 来填。**

### 4）重复 crop_box 是强烈预警信号
如果两个不同 index 拿到了同一个 `(page, crop_box)`，必然至少一个错。
建议在 pipeline 里强制校验：**crop_box 必须唯一**。

## 二、通用流程（提高准确率的做法）

### Step 0：先定“金文/正文”基准
- 把最终目标文字整理成 `gold_text`（建议纯文本，无标点，统一简繁/异体策略）。
- 长度要和目标 glyph 数一致（例如正文 901 字）。

### Step 1：切字时务必保留“可追溯元数据”
每个 glyph 需要至少保留：
- `page`（来自哪一页）
- `grid`（列/行或序号）
- `crop_box`（原图坐标）
- `ocr_guess/ocr_score`（用于对齐和验收，作为“弱真值”）

这些信息决定了后续能不能“只修一个 index”。

### Step 2：用 OCR token 做全局序列对齐（DP）
把 `gold_text` 和 glyph 的 OCR 序列做全局对齐（Needleman–Wunsch/编辑距离 DP）。
推荐的策略：
- match（OCR≈gold）给高分
- mismatch 给惩罚
- gap 给更高惩罚（尽量 1:1）
- 必要时加 band（限制对角线附近），避免把尾部题跋对齐到开头

输出三类信息：
- matched：正文已对齐的位置
- extras：题跋/噪声 glyph（丢弃）
- missing：正文缺字位（必须重裁）

### Step 3：先自动重建“可用版本”，再进入迭代精修
第一版做到“90% 正确”即可，然后通过精修收敛。
精修的原则：
- **只改错的 index**（避免引入新错）
- 每次改动可回滚（保留版本目录 v3/v4/v5...）

### Step 4：薄笔画字（如“一”）要用专门策略
“一”最容易被 OCR 误识、也最容易裁到格子线/引导线。
可复用的策略：
- 在局部区域做连通域分析
- 过滤掉“特别细、铺满整行”的横线（很可能是格子线）
- 只选择“稍厚”的横画组件（min height）
- 对异常结果（笔墨占比极低/极高）做二次检查

### Step 5：验收方法（把用户反馈变成可操作修复）
推荐在前端加 F12 日志，点击字形时打印：
- `index` / `file` / `page` / `grid` / `crop_box`

这样“第 73 字不是之”就变成了：
- “修 `index=73` 的 `crop_box`”

## 三、关于水印（重要教训）

水印处理的关键点：
- **不要改尺寸**（否则所有 crop_box 坐标失效）
- **不要用大矩形遮盖**（会误伤真实笔画）
- 最安全的做法是：
  - 在一个很小的 ROI（左下角）里检测水印像素
  - 用连通域尺寸/形状过滤掉书法笔画
  - 仅对“水印像素”做 inpaint

## 四、建议沉淀为可复用工具链

未来处理其他碑帖建议做成统一 CLI：
- `align`：DP 对齐 + 输出 missing/extras
- `rebuild`：生成 chars 目录
- `annotate`：画框 overlay，辅助人工定位
- `validate`：重复 crop_box 检测 + 高频字抽查 + 末尾段污染检测
